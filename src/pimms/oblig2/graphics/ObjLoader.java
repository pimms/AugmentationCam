package pimms.oblig2.graphics;

import java.util.ArrayList;
import java.util.Scanner;

import android.content.Context;
import android.content.res.AssetManager;
import android.nfc.FormatException;
import android.util.Log;

/*
 * Class to load Polygon File Format files.
 * 
 * It's very important to notice that not all PLY-files
 * are possible to load. This implementation primarily
 * focuses on supporting PLY-files generated by Blender.
 * 
 * Some assumptions regarding input files:
 * 	1.	XYZ is the only valid order for axes. 
 * 		"YXZ", "XY", "Z" and similar are NOT supported.
 * 		
 * 	2.	All vertex data must be bundled. Normals and texture 
 * 		coordinates must be defined in the same list as vertices.
 * 		Vertex indices 
 * 
 *  3.	Types are ignored, and casted to float .
 */
public class ObjLoader {
	private static final String TAG = "3dOBJ";
	private Scanner mFileScanner;
	
	// TODO:
	// Conversion to a single array is inefficient.
	// If time allows it, improve this.
	private ArrayList<float[]> mVertices;
	private ArrayList<short[]> mFaces;
	private ArrayList<float[]> mTexCoord;
	private ArrayList<float[]> mNormals;
	
	public ObjLoader() {
		mVertices = new ArrayList<float[]>();
		mFaces = new ArrayList<short[]>();
		mTexCoord = new ArrayList<float[]>();
		mNormals = new ArrayList<float[]>();
	}
	
	public boolean parseFile(String fileName, Context context) {
		// hehehehehehehehehehehehehehehe 
		AssetManager assManager = context.getAssets();
		
		try {
			mFileScanner = new Scanner(assManager.open(fileName, AssetManager.ACCESS_STREAMING));
		} catch (Exception ex) {
			Log.e(TAG, "Failed to open file " + fileName);
			return false;
		}
		
		try {
			while (mFileScanner.hasNextLine()) {
				parseLine();
			}
		} catch (FormatException e) {
			Log.e(TAG, "Invalid format in OBJ-file: " + e.getMessage());
			return false;
		}
		
		Log.d(TAG, "Loaded OBJ-model with " + mVertices.size() + " vertices");
		
		return true;
	}
	
	
	public float[] getVertices() {
		float[] verts = new float[mVertices.size() * 3];
		fillArrayFromList(verts, mVertices, 3);
		
		return verts;
	}
	
	public float[] getNormals() {
		float[] normals = new float[mNormals.size() * 3];
		fillArrayFromList(normals, mNormals, 3);
		
		return normals;
	}
	
	public short[] getIndices() {
		short[] indices = new short[mFaces.size() * 3];
		fillArrayFromList(indices, mFaces, 3);
		
		return indices;
	}
	
	public float[] getTexCoords() {
		float[] texCoord = new float[mTexCoord.size() * 2];
		fillArrayFromList(texCoord, mTexCoord, 2);
		
		return texCoord;
	}
	
	
	private void fillArrayFromList(float[] arr, ArrayList<float[]> list, int elemSize) {
		int idx = 0;
		
		for (int i=0; i<list.size(); i++) {
			for (int j=0; j<elemSize; j++) {
				arr[idx++] = list.get(i)[j];
			}
		}
	}
	
	private void fillArrayFromList(short[] arr, ArrayList<short[]> list, int elemSize) {
		int idx = 0;
		
		for (int i=0; i<list.size(); i++) {
			for (int j=0; j<elemSize; j++) {
				arr[idx++] = list.get(i)[j];
			}
		}
	}
	
	
	private void parseLine() throws FormatException {
		String next = mFileScanner.next();
		
		if (next.equals("v")) {
			parseVertex();
		} else if (next.equals("f")) {
			parseFace();
		} else if (next.equals("vt")) {
			parseTexCoord();
		} else if (next.equals("vn")) {
			parseNormal();
		} else {
			Log.d(TAG, "Discarding: (" + next + ") " + mFileScanner.nextLine());
		}
	}
	
	private void parseVertex() throws FormatException {
		float[] vert = new float[3];
		for (int i=0; i<3; i++) {
			vert[i] = Float.parseFloat(mFileScanner.next());
		}
		
		mVertices.add(vert);
	}
	
	private void parseFace() throws FormatException {
		String line = mFileScanner.nextLine();
		String[] indices = line.replaceFirst("^ ", "").split(" ");
		
		if (indices.length != 3 && indices.length != 4) {
			//throw new FormatException("Very unable to build a face from "+indices.length+" vertices");
			return;
		}
		
		// Get the face-indices (may be of length 3 or 4)
		short[] face = new short[indices.length];
		for (int i=0; i<indices.length; i++) {
			face[i] = Short.parseShort(indices[i]);
		}
		
		// Divide the face if it's size is 4
		if (face.length == 4) {
			short[] face1 = new short[] {
				face[0], face[1], face[2],
			};
			
			short[] face2 = new short[] {
				face[0], face[2], face[3],	
			};
			
			mFaces.add(face1);
			mFaces.add(face2);
		} else {
			mFaces.add(face);
		}
	}

	private void parseTexCoord() {
		float[] texCoord = new float[2];
		
		for (int i=0; i<2; i++) {
			texCoord[i] = Float.parseFloat(mFileScanner.next());
		}
		
		mTexCoord.add(texCoord);
	}

	private void parseNormal() {
		float[] norm = new float[3];
		for (int i=0; i<3; i++) {
			norm[i] = Float.parseFloat(mFileScanner.next());
		}
		
		mNormals.add(norm);
	}
}
































